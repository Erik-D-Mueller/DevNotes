12:45pm Friday, starting on Node.js and Angular++++++++

It is 4:31pm and I have learned a ton about node.js, http request, javascript and git, I'm going to pause to eat.
4:51pm, back to expanding my knowledge cloud!
I studied until about 6:30pm.

Today is Saturday, June 8th.  Starting to study at 1:54pm.
Got sidetracked looking at facebook, reading articles and researching
Charging scooters in San Francisco.
Finally getting started at 3:24pm, beginning with a 1hr 15min video
Crash course about node express framework.



Stopped watching the express video around 7:50, decided to take a break from it and study java data structures.  Got about half through the 1.25 hour long video.


Stopped at 8:16 to eat ice cream and find/get ibuprofen, my fingers are sore.

I went to the grocery store and got ibuprofen, coffee creamer, chocolate and almonds and back at my computer at 9:07pm. 


Sunday.  I woke up at 9am.  I should have just stayed up, but I thought I might need to go back to sleep for an hour.  I went back to sleep, stayed asleep for 45 mins, then I did the thing where I lay there for hours drifting awake and then asleep again, awake and then asleep again...didn't get out of bed until 12:30.  I feel ashamed.  Then I ate a bit of breakfast, ate ice cream, made coffee, scrolled through facebook for a couple hours, washed my face.  Now it's 1:50pm and I'm finally getting started on studying Java.


I actually only studied for a few mins, then started cleaning my room, because the property manager is coming today and might knock on my bedroom door.  Spent a few hours
Thoroughly cleaning it.  Then I spent two hours reading about Mathew shepherd, not it's 5:19pm and I'm getting started again, until my mouse batteries are "very low" and I think I will have to buy more batteries when they die.








https://www.youtube.com/watch?v=U8XF6AFGqlc
Paypal, Uber, Walmart, Netflix use Node.js
 
(Spent 15 mins replying to Melanie Gulliver)
 
Apache makes a new thread for each client request and eventually maxxes out the memory.  It operates synchronously.
 
Node.js
Single thread, non-blocking, held in event loop.
Node.js uses a single thread for 10s of thousands of requests and is asynchronous.  Other technologies like Apache and PHP use one thread for each request and operate synchronously.
 
NODE.js is used extensively for REST apis, all the http 
 
This developer has another video just for building REST apis with node.
 
NODE.js is good for anything that is not cpu intensive.
 
NPM installs modules into the Node modules folder
-g will install it globally so that it can be accessed from other application.
 
 
Javascript is technically called ECMAscript. So ES15 is javscript2015.

 
Popular Modules: 
 
Express - complete web development framework
Connect - extensive http server framework, baseline for express
Pug / jade which is a template engine and is the default for Express.
 
There are thousands of modules for node that can be installed, usually they are installed in the modules file.

If you use the -g flag when installing a package, then it makes it accessible globally on your computer…

package.json goes in the root of a node application and has all the pertinent details.

“Main” in the package.json file tells node where to begin execution.

We can write the package.json file manually or we can use “npm init” and it will ask us some questions and then create
it for us.

An asterisk, in place of a version number simply means “most up to date”.

LTS is for long term support.
 

DOM for document object model which is the cross platform api that assembles and displays the website based on the html, css and js files.

Type “node” in the command line to open the REPL environment for node. Read, evaluate, print, loop.
Exit it with “ctrl c” twice.

We can make a file, with a .js at the end, open it with an editor like sublime or visual studio, write all the javascript inside of it that we want, then we can go back to the command-line window and write “node ____.js” with the name of the file where the underline part is, and that will run that file from the command line.
 
I need to know the exact technical words for all of the parts of a method including the method signature and all the other little parts.

A node program needs a javascript file to execute and a package.json file.

To make a very very basic web server:

With something like php, you make the php file then upload it to the server and the server takes care of the requests and everything.  With NODE it is different, you have to more like create your own server.

ES2015 uses CONST instead of VAR.  

We can have up to 65535 TCP ports and 65535 UDP ports.

“TCP/IP specifies how data is exchanged over the internet by providing end-to-end communications that identify how it should be broken into packets, addressed, transmitted, routed and received at the destination. TCP/IP requires little central management, and it is designed to make networks reliable, with the ability to recover automatically from the failure of any device on the network.”

TCP is transmission control protocol.

IP for internet protocol defines how to address and route each packet, TCP defines everything else.


Look at const vs var vs let.

A “core module” means it is included in the system by default, hence “core”.

Here is a super simple node.js server:

> const http = require(‘http’);    // This includes the core-module http
> const hostname = ‘127.0.0.1’;  // This is the loop-back address since we are working on our local host for this example
> const port = 3000;  // define a port
> const server = http.createServer(req, res) => {   

 // define a variable called server.  We could do http.createServer(function(requestResponse) but that would be old school we are going to use an arrow function instead.
//So we now have access to the two objets, request and response. 

>res.statusCode=200;  //We want to set a status code.  200 is the status code that says that everything is ok.

> res.setHeader('content-type', 'text/plain');  //We want to set a header and set the content type in the header.

 // The documentation for the http module will show us all of this stuff.

>res.end('Hello World!');  //  This will get outputed to the browser.
>server.listen(port, hostname, ()=> );     // The arrow  => is some sort of shortcut instead of writing the word "function", came out in ES6.

console.log('Server started on  port ' + port);

If we open a terminal and run this program we just made, it will give a blinking cursor, which means that it's running.

He suggests that we check out the express.js crash course after this video.

});     

There are indeed a bunch of GUIs for fixing a merge conflict, but here is a simply way to do it manually:
How to manually fix a merge conflict, by manually reading a merge conflicted file and fixing it.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

How to fix merge conflicts manually:

https://www.youtube.com/watch?v=g8BRcB9NLp4

Information on GIT and SVN which is an older version control system, open source, by apache, decentralized, a lot
more work to do branches and fix merge conflicts.

"git pull" is used to fetch content from a remote repo and bring it back to your local computer repo and immediatley update your local repo.  It assumes that the remote is the "correct, up to date one".

There is a large horde of JSON APIs on github under the username "toddmotto" and the repo name "public-apis".

If there are 4 developers working on a project and there is one central repo on a server, that centralrepo
on the server is what we call the "remote repository".

There is no absolute "upstream" or "downstream" with Git, it's relative, but if 4 people are all pulling and pushing from a central repo
on a server, then they are "downstream" when they pull the code from the central server onto their local computer,
and they are pushing the code "upstream" when they send the changes back to the server.

As if the central server repo is like a water source and the creeks flow outward to each of the
four developers.  It's all relative though, there is no absolute definition.

Git FETCH downloads all the changes from the remote repository onto the person local machine,
but it doesn't force them to merge and accept the changes.  It just downloads them so that
the developer can look at them.  

Git PUSH pushes your local repo and its changes to the remote repo.

GIT Branch is when we want to branch off, like make a copy, so that we can fiddle around and make changes without damaging the original source code, incase we decide
that we don't like the changes that we made and we want to keep the original code.

Working directory is the folder that contains the git folder.

Git checkout is how a developer switches which branch of the remote repo they are working on.  It changes their local repo to match that
branch of the remote repo and it tells the remote repo to record any changes to the checkout branch until the developer "is done" with that branch.

SVN is the apache open source version control system like GIT.  SVN is rather "old school".
SVN is centralized, GIT is decentralized.  Branching and merging on SVN are far more work.

SVN only has one single repository, which is the central one.  Individual developers can make branches and work on
them, but they cannot save different versions or make commits or anything without connecting to the central
repository.  They essentially have a local copy of the file that they're working at and that's basically it.

With GIT, it is decentralized, in that every single developer has their entire own repository, so they
can track their changes and commits on their local repository, even if they don't have internet
access and are never connected to anything else.  With SVN, for subversion, if a developer is 
disconnected from the grid, and they want to have different versions of their code while they're working
they literally have to copy and paste the files, as opposed to it being built into the version control
they way that it is with git.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

In javascript, an expression is any valid set of literals, variables, operators, and expressions that evaluates to a single value. 
The value may be a number, a string, or a logical value. Conceptually, there are two types of expressions: those that assign a 
value to a variable, and those that simply have a value.

With functions in javascript, you can make them the regular 
way with the function declaration, aka function statement, aka function keyword:

function calcRectArea(width, height) {
  return width * height;
}

OR you can use the function constructor, denoted by the capital-f "Function" paired with a function expression:

var sum = new Function('a', 'b', 'return a + b');

Calling the constructor directly can create functions dynamically, but they "execute in the global scope only", I'm not
sure what that means.

I could not get a clear understanding of dynamic functions other than that they can change themselves, or be swapped out at runtime
and or sometimes related to needing to change themselves in relation to what browser the user is using.
s


++++++++++++++++++

Node Express Framework crash course

Express is a fast, unopinionated (low level) minimalist web framework for Node.js.  Unopinonated meaning you set things up however you want, you're not forced to do things in a specific way.

Commonly used in connection with React or Angular.

Commonly used with an API to interact with the front end.

Views can indeed be rendered with Express directly, with plain html or a template
Engine like handlebars or pug, there are a lot of options for the front end.

Express makes building node-webapps about 100 times easier.

Express is used with JSON serving APIs as well as back end applications to render pages on a server.

COA, HappyJS and Adonis are other frameworks.  COA and HappyJS are similar, Adonis is much higher level, similar to Laravel for PHP, but because it is higher level, we don't have as much freedom.

Express is by far the most popular Node Framework.

=> is somehow used to replace the function word in EC6.


Higher order array methods, foreach, map,filter.

https://www.youtube.com/watch?v=L72fhGm1tfE
5:15 in is when he shows the most basic script to start running express

Express lets use store the "routers" in different files, which makes it
Easier to work with, as opposed to other frameworks which apparently force you to put all the routers in the same file.

Middleware has access to both the request properties and the response properties.

Postman is an http client.

The -y flag with nom init makes us not have to answer any questions.

npm I express //installs express

It gets added to the package.json file.



/ is the route for the index page.



function(requires){}  is the same thing as    (req, res) => {}



Express comes with functionality to set a specific folder as the static folder, and that way we can just put an index.html file and all the other static resources in there and it will function as as static website.

app.get('/', (req, res) => { // We use "app" to create a route, then we use the type of request it will handle, in this case a "get" request.

    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

"Routing" refers to determining how an application responds to a client request.





This is the code to simply serve static content from a folder from an express
Server, in this case the folder would be called "public":

app.get('/', (req, res) => { // We use "app" to create a route, then we use the type of request it will handle, in this case the folder is 'public" and index.html is the file that is the homepage.

    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});
 25:35



Middleware always takes in request, response, next


